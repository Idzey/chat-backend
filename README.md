# Chat Backend

Backend-сервис для чата на базе [NestJS](https://nestjs.com/) с адаптером [Fastify](https://www.fastify.io/).  
Поддерживает аутентификацию через Passport, работу с базой данных через Prisma, realtime-коммуникацию через Socket.IO и загрузку/хранение файлов в S3-совместимом хранилище (MinIO / AWS S3).

## Стек технологий

- **Node.js / TypeScript**
- **NestJS** (с адаптером **Fastify**)
- **Passport** — аутентификация и авторизация
- **Prisma** — ORM / работа с базой данных
- **Socket.IO** — realtime-чаты, события
- **MinIO / AWS S3** — хранение файлов (медиа, вложения)

---

## Возможности

- Регистрация и авторизация пользователей
- JWT / session-based аутентификация (уточни, если по-другому)
- Создание и управление чатами / диалогами
- Отправка и получение сообщений в реальном времени через Socket.IO
- Хранение истории сообщений в базе через Prisma
- Загрузка и хранение файлов (изображения, документы и т.п.) в MinIO (S3-совместимое хранилище)
- Разделение окружений (development / production) через переменные среды

> При желании опиши тут бизнес-особенности: личные/групповые чаты, статус «онлайн», редактирование/удаление сообщений и т.д.

---

## Запуск проекта

### Предварительные требования

- Node.js (актуальная LTS-версия, например 20.x)
- npm или yarn / pnpm
- Docker + Docker Compose (если используешь для БД и MinIO)
- Настроенные переменные окружения (см. ниже)

### Установка

```bash
# Клонируем репозиторий
git clone https://github.com/Idzey/chat-backend.git
cd chat-backend

# Устанавливаем зависимости
npm install
# или
yarn install
# или
pnpm install
```

### Конфигурация окружения

Создай файл `.env` в корне проекта (или используй `.env.example`, если он есть):

```env
# Пример — адаптируй под свою конфигурацию

# HTTP-сервер
PORT=3000

# База данных (Prisma)
DATABASE_URL="postgresql://user:password@localhost:5432/chat?schema=public"

# JWT / Passport
JWT_SECRET="super-secret"
JWT_EXPIRES_IN="7d"

# S3 / MinIO
S3_ENDPOINT="http://localhost:9000"
S3_ACCESS_KEY="minio-access-key"
S3_SECRET_KEY="minio-secret-key"
S3_BUCKET_NAME="chat-files"
S3_USE_SSL=false

# Прочие настройки (логирование, CORS и т.д.)
NODE_ENV="development"
```

Если используешь Docker Compose для БД и MinIO, добавь сюда ссылку на `docker-compose.yml` и пример запуска:

```bash
docker compose up -d
```

---

### Миграции Prisma

После настройки `DATABASE_URL`:

```bash
# Генерация Prisma Client
npx prisma generate

# Применение миграций
npx prisma migrate deploy
# или для разработки
npx prisma migrate dev
```

---

### Запуск сервера

```bash
# development
npm run start:dev

# production build
npm run build
npm run start:prod
```

По умолчанию приложение поднимается на `http://localhost:3000` (или на том порту, который указан в `PORT`).

---

## Архитектура

Проект организован по стандартной структуре NestJS:

- `src/modules/auth` — аутентификация, стратегии Passport, Guard’ы, выдача токенов
- `src/modules/users` — управление пользователями
- `src/modules/chat` — чаты/диалоги, сообщения
- `src/modules/socket` — Socket.IO gateway’и
- `src/modules/files` — интеграция с MinIO / AWS S3 для загрузки и получения файлов
- `prisma/schema.prisma` — описание схемы БД

---

## Аутентификация (Passport)

Используется **Passport** (например, `passport-jwt`):

- Регистрация / логин через REST-эндпоинты
- **Access-токен** — JWT (подписывается сервером, короткоживущий)
- **Refresh-токен** — opaque (не JWT, хранится и валидируется на сервере)
- Доступ к защищённым ресурсам через NestJS Guards (`AuthGuard('jwt')` и т.п.)
- Поддержка разных типов устройств (для каждого устройства может быть свой refresh-токен и своя сессия)

Пример потоков:
1. Клиент отправляет креды (`/auth/login`).
2. В ответ получает:
   - JWT access-токен (для авторизации в API и при подключении к Socket.IO),
   - opaque refresh-токен (для обновления access-токена).
3. Клиент использует access-токен в заголовке  
   `Authorization: Bearer <access_token>`  
   для защищённых запросов и подключения к Socket.IO.
4. При истечении access-токена клиент отправляет refresh-токен на соответствующий эндпоинт (например, `/auth/refresh`) и получает новый access-токен (и при необходимости новый refresh-токен).
5. Для разных устройств (web, mobile и т.п.) сервер может выдавать отдельные refresh-токены, позволяя управлять сессиями и разлогинивать конкретные устройства.
---

## Реальное время (Socket.IO)

Socket.IO используется для:

- Подключения пользователей к комнатам (чаннелам/чатам)
- Отправки и получения сообщений в реальном времени
- Обновления статусов (онлайн/офлайн, seen, typing и др. — если реализовано)

Типичный flow:
1. Клиент подключается к Socket.IO с JWT-токеном (через query или headers).
2. Сервер аутентифицирует пользователя и привязывает его к сокету.
3. Клиент вступает в комнату чата (например, `room:<chatId>`).
4. Сообщения отправляются в комнату и сохраняются в БД через Prisma.

---

## Хранение файлов (MinIO / AWS)

Файлы (изображения, документы и др.) загружаются через REST-эндпоинты или специальный модуль:

- Файл принимается сервером
- Сохраняется в S3-совместимое хранилище (MinIO или AWS S3)
- В базе (Prisma) сохраняется метаинформация/URL
- Клиент получает ссылку для скачивания/просмотра

Переменные окружения (`S3_ENDPOINT`, `S3_ACCESS_KEY`, `S3_SECRET_KEY`, `S3_BUCKET_NAME`) используются для настройки клиента.

---
